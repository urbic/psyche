<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="PsiReference_Language">
<title>Language</title>

&PsiReference_Language_Interpreter;
&PsiReference_Language_Syntax;
&PsiReference_Language_CoreTypes;

<section xml:id="PsiReference_Language_Stacks">
<title>Stacks</title>

<para>
The Ψ interpreter supports several stacks intended to store data during the
program execution or represent the program execution state.  Three of them are
essential: the <firstterm>operand stack</firstterm><indexterm><primary>operand
stack</primary></indexterm>, the <firstterm>dictionary
stack</firstterm><indexterm><primary>dictionary stack</primary></indexterm> and
the <firstterm>execution stack</firstterm><indexterm><primary>execution
stack</primary></indexterm>.
</para>

<para>
Каждый из стеков устроен по принципу <acronym>LIFO</acronym> — <foreignphrase
xml:lang="en">Last In—First Out</foreignphrase> (последний пришёл — первый ушёл).
</para>

<section xml:id="PsiReference_Language_Stacks_OperandStack">
<title>Operand Stack</title>

<para>
Исполнение литеральных объектов всегда приводит к их добавлению в стек
операндов. Если оператор нуждается в данных для обработки, он снимает нужное
количество объектов их со стека операндов. Объекты, созданные в результате
работы оператора, добавлются в этот стек. Так действует большинство операторов
языка. Таким образом, свободно манипулировать стеком операндов может как
интерпретатор, так и любой из операторов.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_DictionaryStack">
<title>Dictionary Stack</title>

<para>
The dictionary stack can store only dictionaries. The current stack of the
dictionary stack serves as a context of search for objects by name. The need
for such a search occurs every time the interpreter encounters a command. There
are several operators to manipulate the dictionary stack.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_ExecutionStack">
<title>Execution Stack</title>

<para>
The execution stack reflects the execution phase of the procedure. During
execution of the procedure its elements are loaded onto the execution stack in
reverse order, so that the very first element is at the top of the stack. The
interpreter then in turn removes objects from the execution stack and executes
them until the stack level is equal to the original (that was at the beginning
of the procedure execution).
</para>

<para>
The execution stack may be controlled by the interpreter. Only a few operators
directly operating the execution stack. This is control operators that
implement cycles.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_Auxiliary">
<title>Auxiliary Stacks</title>

<para>
In addition to three main stacks, there are several auxiliary stacks built into
the interpreter: <firstterm>exit stack</firstterm><indexterm><primary>exit
stack</primary></indexterm> и <firstterm>stop
stack</firstterm><indexterm><primary>stop stack</primary></indexterm>. Only a
few control operators operate on auxiliary stacks.
</para>

</section>

</section>

<section xml:id="PsiReference_Language_ObjectExecution">
<title>Execution of Objects</title>

<para>
Смысл исполнения объекта зависит от его типа, а также от того, получен этот
объект парсером или же другим способом. Здесь нужно отметить, что существует
лишь два типа исполненяемых объектов, получаемых непосредственно парсером — это
процедуры и команды.

<itemizedlist>

<listitem>
Исполняемый оператор вызывается, то есть выполняется запрограммированное в нём
действие.
</listitem>

<listitem>
Объекты всех прочих типов загружаются на стек операндов.
</listitem>

</itemizedlist>

</para>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding">
<title>Early Name Binding</title>

<section xml:id="PsiReference_Language_EarlyNameBinding_BindOperator">
<title><xref xrefstyle="template:%t" linkend="PsiReference_Operators_Details_bind"/> operator</title>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding_Immediate">
<title>Immediate Names</title>

</section>

</section>

&PsiReference_Language_IO;
&PsiReference_Language_MultipleContextExecution;
&PsiReference_Language_Errors;

<section xml:id="PsiReference_Language_Grammar">
<title>Grammar</title>

<productionset>
<title>Grammar rules for tokens</title>

<production xml:id="PsiReference_Language_Grammar_Token">
<lhs>TOKEN</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerHexadecimal">INTEGER_HEXADECIMAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerBinary">INTEGER_BINARY</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Char">CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Real">REAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_String">STRING</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExp">REGEXP</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Immediate">IMMEDIATE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_OpenBrace">OPEN_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CloseBrace">CLOSE_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Comment">COMMENT</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Sign">
<lhs>SIGN</lhs>
<rhs>[<constant>"+"</constant>, <constant>"-"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Digit">
<lhs>DIGIT</lhs>
<rhs>[<constant>"0"</constant> - <constant>"9"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerUnsigned">
<lhs>INTEGER_UNSIGNED</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Integer">
<lhs>INTEGER</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_HexDigit">
<lhs>HEXDIGIT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>
| [<constant>"A"</constant> - <constant>"F"</constant>,
<constant>"a"</constant> - <constant>"f"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerHexadecimal">
<lhs>INTEGER_HEXADECIMAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"X"</constant>,
<constant>"x"</constant>]
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerBinary">
<lhs>INTEGER_BINARY</lhs>
<rhs>
<nonterminal def="PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"B"</constant>, <constant>"b"</constant>]
[<constant>"0"</constant>, <constant>"1"</constant>]+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Char">
<lhs>CHAR</lhs>
<rhs>
<constant>"`"</constant>
(~[<constant>"\\"</constant>]
| <nonterminal def="PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>)
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RealUnsigned">
<lhs>REAL_UNSIGNED</lhs>
<rhs>
(<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
(<constant>"."</constant>
<nonterminal>DIGIT</nonterminal>*)?
| <constant>"."</constant>
<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>)
<nonterminal def="PsiReference_Language_Grammar_Exponent">EXPONENT</nonterminal>?
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Real">
<lhs>REAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_RealUnsigned">REAL_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Exponent">
<lhs>EXPONENT</lhs>
<rhs>
[<constant>"E"</constant>, <constant>"e"</constant>]
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Comment">
<lhs>COMMENT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_CommentOneLine">COMMENT_ONELINE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CommentMultiline">COMMENT_MULTILINE</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentOneLine">
<lhs>COMMENT_ONELINE</lhs>
<rhs>
<constant>"#"</constant>
(~[<constant>"\n"</constant>])*
<constant>"\n"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentMultiline">
<lhs>COMMENT_MULTILINE</lhs>
<rhs>
<constant>"/#"</constant>
(~[<constant>"/"</constant>]
| (<constant>"/"</constant> ~[<constant>"#"</constant>]))*
<constant>"#/"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_String">
<lhs>STRING</lhs>
<rhs>
<constant>"\""</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| ~[ <constant>"\""</constant>,
<constant>"\\"</constant>])*
<constant>"\""</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_StringSpecial">
<lhs>STRING_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
([<constant>"0"</constant>,
<constant>"a"</constant>,
<constant>"n"</constant>,
<constant>"t"</constant>,
<constant>"f"</constant>,
<constant>"\""</constant>,
<constant>"\\"</constant>,
<constant>"e"</constant>,
<constant>"r"</constant>,
<constant>"\n"</constant>]
<sbr/>
| <constant>"u"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>{4}
| <constant>"x{"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+
<constant>"}"</constant>
| <constant>"c"</constant>
[<constant>"\u0000" - "\u00FF"</constant>])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExp">
<lhs>REGEXP</lhs>
<rhs>
<constant>"@"</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExpSpecial">REGEXP_SPECIAL</nonterminal>
| ~[<constant>"@"</constant>,
<constant>"\\"</constant>])*
<constant>"@"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExpSpecial">
<lhs>REGEXP_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
(~[])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Name">
<lhs>NAME</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Immediate">
<lhs>IMMEDIATE</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Command">
<lhs>COMMAND</lhs>
<rhs>
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>)
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>)*<sbr/>
| [<constant>"["</constant>,
<constant>"]"</constant>,
<constant>"("</constant>,
<constant>")"</constant>,
<constant>"&lt;"</constant>,
<constant>"&gt;"</constant>,
<constant>"="</constant>,
<constant>"?"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_OpenBrace">
<lhs>OPEN_BRACE</lhs>
<rhs><constant>"{"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CloseBrace">
<lhs>CLOSE_BRACE</lhs>
<rhs><constant>"}"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Letter">
<lhs>LETTER</lhs>
<rhs>
[<constant>"A"</constant> - <constant>"Z"</constant>,
<constant>"a"</constant> - <constant>"z"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_NameSpecialChar">
<lhs>NAME_SPECIAL_CHAR</lhs>
<rhs>
[<constant>"_"</constant>,
<constant>"."</constant>,
<constant>"+"</constant>,
<constant>"-"</constant>,
<constant>"="</constant>,
<constant>"$"</constant>]
</rhs>
</production>

</productionset>

</section>

</chapter>
