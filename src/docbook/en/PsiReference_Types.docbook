<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="PsiReference_Types">
<title>Types</title>

<para>
The Ψ language has a flexible and extendable type system. The types implemented
as Java classes or interfaces. Each Ψ object is represented as an object of
some class implementing the <classname>PsiObject</classname> interface.
</para>

<para>
Extensibility of the type system is based on the Java programming new classes
from <classname>PsiObject</classname>. The creation of new types by means of
Ψ language is impossible.
</para>

<para>
Majority of Ψ operators expect operands of certain type. So, the addition
operator <xref xrefstyle="template:%t"
linkend="PsiReference_Operators_Details_add"/> can be applied to the numbers,
but not to strings.
</para>

<para>
Some operators are polymorphic, that is able to change its meaning in
accordance with the type of its operands. For example, the same operator <xref
xrefstyle="template:%t" linkend="PsiReference_Operators_Details_add"/> for
integer operands returns integer (except in the case where the sum is beyond
the boundaries of integer type; then the result is real). If one of the
operands is an integer, and the other is a real, or both are real, the result
will also have a real type. If at least one of the operands has the complex
type, the result will have the same type. Another example: the <xref
xrefstyle="template:%t" linkend="PsiReference_Operators_Details_or"/> operator
returns the disjunction of its operands. If both operands are of boolean type,
the result will be boolean, and if both operands are integer, bitwise
disjunction is calculated, and the result will be integer.
</para>

<para>
Реализация оператора на Java, как правило, пытается привести тип операнда
к желательному. Соответствующий код помещается в блок, в котором
перехватывается исключение <classname>ClassCastException</classname>. Перехват
исключения вызывает ошибку <xref xrefstyle="template:%t"
linkend="PsiReference_Errors_Details_typecheck"/> во время исполнения
Ψ-программы. Таким образом, можно приспособить уже запрограммированный оператор
к новым типам операндов, не меняя его код. Для этого класс, соответствующий
новому типу, должен наследовать у имеющегося класса или реализовывать имеющийся
интерфейс.
</para>

<section xml:id="PsiReference_Types_Details">
<title>Types in Detail</title>

&PsiReference_Types_Details_additive;
&PsiReference_Types_Details_appendable;
&PsiReference_Types_Details_arithmetic;
&PsiReference_Types_Details_array;
&PsiReference_Types_Details_arraylike;
&PsiReference_Types_Details_atomic;
&PsiReference_Types_Details_biginteger;
&PsiReference_Types_Details_bitarray;
&PsiReference_Types_Details_bitset;
&PsiReference_Types_Details_bitwise;
&PsiReference_Types_Details_blockingqueue;
&PsiReference_Types_Details_boolean;
&PsiReference_Types_Details_bounded;
&PsiReference_Types_Details_clearable;
&PsiReference_Types_Details_closeable;
&PsiReference_Types_Details_command;
&PsiReference_Types_Details_complex;
&PsiReference_Types_Details_condition;
&PsiReference_Types_Details_container;
&PsiReference_Types_Details_context;

<section xml:id="PsiReference_Types_Details_convertabletointeger">
<title><type>convertabletointeger</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_integer"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletoname">
<title><type>convertabletoname</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_name"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletostring">
<title><type>convertabletostring</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_string"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletoreal">
<title><type>convertabletoreal</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_real"/>.
</para>
</section>

&PsiReference_Types_Details_dict;
&PsiReference_Types_Details_dictlike;
&PsiReference_Types_Details_evaluable;
&PsiReference_Types_Details_filereader;
&PsiReference_Types_Details_filewriter;
&PsiReference_Types_Details_flushable;
&PsiReference_Types_Details_indexed;
&PsiReference_Types_Details_input;
&PsiReference_Types_Details_integer;
&PsiReference_Types_Details_iterable;
&PsiReference_Types_Details_lengthy;
&PsiReference_Types_Details_lock;
&PsiReference_Types_Details_logical;
&PsiReference_Types_Details_mark;
&PsiReference_Types_Details_matcher;
&PsiReference_Types_Details_name;
&PsiReference_Types_Details_null;
&PsiReference_Types_Details_numeric;
&PsiReference_Types_Details_object;
&PsiReference_Types_Details_operator;
&PsiReference_Types_Details_output;
&PsiReference_Types_Details_proc;
&PsiReference_Types_Details_queuelike;
&PsiReference_Types_Details_random;
&PsiReference_Types_Details_readable;
&PsiReference_Types_Details_reader;
&PsiReference_Types_Details_real;
&PsiReference_Types_Details_realnumeric;
&PsiReference_Types_Details_regexp;
&PsiReference_Types_Details_resettable;
&PsiReference_Types_Details_scalar;
&PsiReference_Types_Details_set;
&PsiReference_Types_Details_setlike;
&PsiReference_Types_Details_string;
&PsiReference_Types_Details_stringreader;
&PsiReference_Types_Details_stringwriter;
&PsiReference_Types_Details_stringy;
&PsiReference_Types_Details_type;
&PsiReference_Types_Details_writable;
&PsiReference_Types_Details_writer;

</section>

</chapter>
