<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="PsiReference_Types">
<title>Типы</title>

<para>
В языке Ψ имеется гибкая и расширяемая система типов. Типы реализованы как
классы или интерфейсы языка Java. Каждый объект в Ψ представлен как объект
некоторого класса, реализующий интерфейс <classname>PsiObject</classname>.
</para>

<para>
Расширяемость системы типов достигается за счёт программирования на Java новых
производных от <classname>PsiObject</classname> классов. Создание новых типов
средствами Ψ невозможно.
</para>

<para>
Большинство операторов Ψ рассчитывают на определённый тип своих операндов. Так,
оператор сложения <xref xrefstyle="template:%t"
linkend="PsiReference_Operators_Details_add"/> может применяться к числам, но
не к строкам.
</para>

<para>
Некоторые операторы полиморфны, то есть способны менять свой смысл
в соответствии с типом своих операндов. К примеру, тот же оператор <xref
xrefstyle="template:%t" linkend="PsiReference_Operators_Details_add"/>
для целочисленных операндов возвращает результат целого типа (за исключением
того случая, когда сумма выходит за границы целого типа; тогда результат имеет
вещественный тип). Если один из операндов целый, а другой — вещественный,
или же оба вещественные, результат также будет иметь вещественный тип. Если
хотя бы один из операторов имеет комплексный тип, такого же типа будет
результат. Другой пример: оператор <xref xrefstyle="template:%t"
linkend="PsiReference_Operators_Details_or"/> вычисляет дизъюнкцию своих
операндов. Если оба операнда булевского типа, результат будет булевским, а если
оба операнда целочисленные, выполняется побитовая дизъюнкция, и результат будет
целым числом.
</para>

<para>
Реализация оператора на Java, как правило, пытается привести тип операнда
к желательному. Соответствующий код помещается в блок, в котором
перехватывается исключение <classname>ClassCastException</classname>. Перехват
исключения вызывает ошибку <xref xrefstyle="template:%t"
linkend="PsiReference_Errors_Details_typecheck"/> во время исполнения
Ψ-программы. Таким образом, можно приспособить уже запрограммированный оператор
к новым типам операндов, не меняя его код. Для этого класс, соответствующий
новому типу, должен наследовать у имеющегося класса или реализовывать имеющийся
интерфейс.
</para>

<section xml:id="PsiReference_Types_Details">
<title>Типы детально</title>

<!--section xml:id="PsiReference_Types_Details_abstractarray">
<title><type>abstractarray</type></title>
<para>
Тип абстрактных массивов, проиндексированных целыми неотрицательными числами
последовательностей объектов.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_arraylike"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_object"/>.
</formalpara>
</section-->

<!--section xml:id="PsiReference_Types_Details_abstractdictionary">
<title><type>abstractdictionary</type></title>
<para>
Тип абстрактных словарей.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_dictlike"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_object"/>.
</formalpara>
</section-->

<!--section xml:id="PsiReference_Types_Details_abstractset">
<title><type>abstractset</type></title>
<para>
Тип абстрактного множества.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_object"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_setlike"/>.
</formalpara>
</section-->

<!--section xml:id="PsiReference_Types_Details_abstractstring">
<title><type>abstractstring</type></title>
<para>
Тип абстрактных строк, проиндексированных целыми неотрицательными числами
целочисленных последовательностей.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_abstractstringlike"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_arraylike"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_stringlike"/>.
</formalpara>
</section-->

<!--section xml:id="PsiReference_Types_Details_abstractstringlike">
<title><type>abstractstringlike</type></title>
<para>
Тип абстрактных строкоподобных величин.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_object"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_stringlike"/>.
</formalpara>
</section-->

&PsiReference_Types_Details_appendable;
&PsiReference_Types_Details_arithmetic;
&PsiReference_Types_Details_array;
&PsiReference_Types_Details_arraylike;
&PsiReference_Types_Details_atomic;
&PsiReference_Types_Details_bitvector;
&PsiReference_Types_Details_bitset;
&PsiReference_Types_Details_boolean;
&PsiReference_Types_Details_clearable;
&PsiReference_Types_Details_closeable;
&PsiReference_Types_Details_command;
&PsiReference_Types_Details_complex;

<section xml:id="PsiReference_Types_Details_complexnumeric">
<title><type>complexnumeric</type></title>
<para>
Тип объектов, которые могут рассматриваться как комплексные числа. Целый,
вещественный и комплексный типы являются производными от этого типа.
</para>
<formalpara>
<title>Наследует:</title>
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_arithmetic"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_atomic"/>,
<xref xrefstyle="template:%t" linkend="PsiReference_Types_Details_object"/>.
</formalpara>
</section>

&PsiReference_Types_Details_condition;
&PsiReference_Types_Details_container;
&PsiReference_Types_Details_context;

<section xml:id="PsiReference_Types_Details_convertabletointeger">
<title><type>convertabletointeger</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_integer"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletoname">
<title><type>convertabletoname</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_name"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletostring">
<title><type>convertabletostring</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_string"/>.
</para>
</section>

<section xml:id="PsiReference_Types_Details_convertabletoreal">
<title><type>convertabletoreal</type></title>
<para>
Тип объектов, которые могут быть преобразованы к типу <xref
xrefstyle="template:%t"
linkend="PsiReference_Types_Details_real"/>.
</para>
</section>

&PsiReference_Types_Details_dict;
&PsiReference_Types_Details_dictlike;
&PsiReference_Types_Details_evaluable;
&PsiReference_Types_Details_filereader;
&PsiReference_Types_Details_filewriter;
&PsiReference_Types_Details_flushable;
&PsiReference_Types_Details_indexed;
&PsiReference_Types_Details_integer;
&PsiReference_Types_Details_iterable;
&PsiReference_Types_Details_lengthy;
&PsiReference_Types_Details_lock;
&PsiReference_Types_Details_logical;
&PsiReference_Types_Details_mark;
&PsiReference_Types_Details_matcher;
&PsiReference_Types_Details_name;
&PsiReference_Types_Details_null;
&PsiReference_Types_Details_numeric;
&PsiReference_Types_Details_object;
&PsiReference_Types_Details_operator;
&PsiReference_Types_Details_proc;
&PsiReference_Types_Details_random;
&PsiReference_Types_Details_readable;
&PsiReference_Types_Details_reader;
&PsiReference_Types_Details_real;
&PsiReference_Types_Details_regexp;
&PsiReference_Types_Details_resettable;
&PsiReference_Types_Details_scalar;
&PsiReference_Types_Details_set;
&PsiReference_Types_Details_setlike;
&PsiReference_Types_Details_string;
&PsiReference_Types_Details_stringlike;
&PsiReference_Types_Details_stringreader;
&PsiReference_Types_Details_stringwriter;
&PsiReference_Types_Details_writable;
&PsiReference_Types_Details_writer;

</section>

</chapter>
