<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="PsiReference_Language">
<title>Язык</title>

<section xml:id="PsiReference_Language_Interpreter">
<title>Интерпретатор</title>

<para>
Интерпретатор работает с так называемыми
<firstterm>объектами</firstterm><indexterm><primary>объект</primary></indexterm>
языка Ψ. Некоторые из них представляют данные, такие как числа, булевские
значения, строки или контейнеры. Другие объекты рассматриваются как инструкции
и подлежат исполнению — команды, процедуры, операторы. Однако в языке нет
принципиальных различий между данными и инструкциями — любой объект может,
в зависимости от ситуации, рассматриваться или как данные, или как инструкция.
</para>

<para>
Интерпретатор читает текст программы, извлекая из него
<firstterm>лексемы</firstterm><indexterm><primary>лексема</primary></indexterm>,
также называемые
<firstterm>токенами</firstterm><indexterm><primary>токен</primary></indexterm>.
Часть интерпретатора, которая последовательно извлекает токены из текста
программы, называется
<firstterm>парсером</firstterm><indexterm><primary>парсер</primary></indexterm>.
В большинстве случаев прочитанный токен преобразуется в объект, который
немедленно исполняется. Результат исполнения объекта полностью определяется его
<firstterm>типом</firstterm><indexterm><primary>тип</primary><secondary>объекта</secondary></indexterm>,
<firstterm>атрибутами</firstterm><indexterm><primary>атрибут</primary><secondary>объекта</secondary></indexterm>
и его
<firstterm>значением</firstterm><indexterm><primary>значение</primary><secondary>объекта</secondary></indexterm>.
Особый вид токенов,
<firstterm>комментарий</firstterm><indexterm><primary>комментарий</primary></indexterm>,
игнорируется интерпретатором. Объекты некоторых типов не могут быть созданы
из токенов, но они могут возникать как результат исполнения операторов.
</para>

<para>
Для хранения данных во время исполнения программы интерпретатор имеет несколько
<firstterm>стеков</firstterm>, которым посвящён раздел <xref
linkend="PsiReference_Language_Stacks"/>.
</para>

</section>

<section xml:id="PsiReference_Language_Syntax">
<title>Синтаксис</title>

<section xml:id="PsiReference_Language_Syntax_Comments">
<title>Комментарии</title>

<para>
<firstterm>Комментарии</firstterm> — часть текста программы, игнорируемой
парсером. В языке Ψ предусмотрено два типа комментариев — однострочные и
многострочные.
</para>

<section xml:id="PsiReference_Language_Syntax_Comments_OneLine">
<title>Однострочные комментарии</title>

<para>
Символ <literal>#</literal> вне строкового литерала или регулярного выражения
начинает <firstterm>однострочный
комментарий</firstterm><indexterm><primary>комментарий</primary><secondary>однострочный</secondary></indexterm>.
Он состоит из символов, следующих после <literal>#</literal> вплоть до символа
конца строки.
</para>

<para>
Комментарий вида <literal>#!…</literal> в первой строке программы
в юниксоподобных операционных системах играют роль
<firstterm>шебанга</firstterm><indexterm><primary>шебанг</primary></indexterm>.
К примеру, программа, начинающаяся со строки

<programlisting language="psi">#!/usr/bin/psylla</programlisting>

и помещённая в исполняемый файл, будет исполняться интерпретатором
<command>/usr/bin/psylla</command>.

</para>

</section>

<section xml:id="PsiReference_Language_Syntax_Comments_MultiLine">
<title>Многострочные комментарии</title>

<para>
Символы <literal>/#</literal> вне строкового литерала или регулярного выражения
служат началом <firstterm>многострочного
комментария</firstterm><indexterm><primary>комментарий</primary><secondary>многострочный</secondary></indexterm>,
продолжающегося до ближайших символов <literal>#/</literal>. Вложение
многострочных комментариев друг в друга не допускается.
</para>

</section>

</section>

<section xml:id="PsiReference_Language_Syntax_Numbers">
<title>Числа</title>

<para>
В программе могут создаваться числовые объекты целого, вещественного и
комплексного типов. В языке предусмотрено литеральное представление только
для целых и вещественных чисел.  Целые числа могут записываться в десятичной,
шестнадцатеричной или двоичной форме.
</para>

<section xml:id="PsiReference_Language_Syntax_Numbers_Decimal">
<title>Десятичные литералы</title>

<para>
<firstterm>Десятичные
литералы</firstterm><indexterm><primary>литерал</primary><secondary>десятичный</secondary></indexterm>
состоят из десятичных цифр. Кроме того, они могут содержать единственную
десятичную точку <literal>.</literal> и начинаться с необязательного знака
<literal>+</literal> или <literal>-</literal>.
</para>

<para>
Литералы, не содержащие десятичной точки, обычно приводят к созданию
целочисленного объекта. В случае, если обозначаемое число выходит за границы
допустимых значений целых чисел, создаётся вещественный объект.
</para>

</section>

<section xml:id="PsiReference_Language_Syntax_Numbers_Hexadecimal">
<title>Шестнадцатеричные литералы</title>

<para>
<firstterm>Шестнадцатеричные
литералы</firstterm><indexterm><primary>литерал</primary><secondary>шестнадцатеричный</secondary></indexterm>
начинаются с необязательного знака <literal>+</literal> или
<literal>-</literal>, символов <literal>0X</literal> или <literal>0x</literal>
и завершаются произвольным количеством шестнадцатеричных цифр
<literal>0</literal>—<literal>9</literal> и
<literal>A</literal>—<literal>F</literal> или
<literal>a</literal>—<literal>f</literal>.
</para>

</section>

<section xml:id="PsiReference_Language_Syntax_Numbers_Binary">
<title>Двоичные литералы</title>

<para>
<firstterm>Двоичные
литералы</firstterm><indexterm><primary>литерал</primary><secondary>двоичный</secondary></indexterm>
начинаются с необязательного знака <literal>+</literal> или
<literal>-</literal>, символов <literal>0B</literal> или <literal>0b</literal>
и завершаются произвольным количеством двоичных цифр <literal>0</literal> или
<literal>1</literal>.
</para>

</section>


</section>

<section xml:id="PsiReference_Language_Syntax_Strings">
<title>Строки</title>

<para>
Строковые литералы заключаются между двойными кавычками <literal>"</literal>
(<constant>U+22</constant>). Бэкслэш <literal>\</literal>
(<constant>U+5C</constant>) между кавычками имеет особый смысл, определяемый
следующим за ним символом.

<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry><literal>\0</literal></entry>
<entry>нулевой символ, <constant>U+0</constant></entry>
</row>
<row>
<entry><literal>\a</literal></entry>
<entry>гудок, <constant>U+7</constant></entry>
</row>
<row>
<entry><literal>\t</literal></entry>
<entry>символ табуляции, <constant>U+9</constant></entry>
</row>
<row>
<entry><literal>\n</literal></entry>
<entry>конец строки, <constant>U+A</constant></entry>
</row>
<row>
<entry><literal>\f</literal></entry>
<entry>конец страницы, <constant>U+C</constant></entry>
</row>
<row>
<entry><literal>\r</literal></entry>
<entry>возврат каретки, <constant>U+D</constant></entry>
</row>
<row>
<entry><literal>\e</literal></entry>
<entry>escape, <constant>U+1B</constant></entry>
</row>
<row>
<entry><literal>\"</literal></entry>
<entry>двойная кавычка <literal>"</literal> <constant>U+22</constant></entry>
</row>
<row>
<entry><literal>\\</literal></entry>
<entry>бэкслэш <literal>\</literal> <constant>U+5C</constant></entry>
</row>
<row>
<entry><literal>\u<replaceable>XXXX</replaceable></literal></entry>
<entry>символ <constant>U+<replaceable>XXXX</replaceable></constant></entry>
</row>
<row>
<entry><literal>\x{<replaceable>XXXXXXXX</replaceable>}</literal></entry>
<entry>символ <constant>U+<replaceable>XXXXXXXX</replaceable></constant></entry>
</row>
<row>
<entry><literal>\N{<replaceable>name</replaceable>}</literal></entry>
<entry>символ с именем Unicode <replaceable>name</replaceable> <remark>(не реализовано)</remark></entry>
</row>
<row>
<entry><literal>\c<replaceable>C</replaceable></literal></entry>
<entry>для символов <replaceable>C</replaceable> от <constant>U+0</constant>
до <constant>U+3F</constant> прибавляет к коду 64, для символов
от <constant>U+40</constant> до <constant>U+7F</constant> вычитает 64
из кода</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</para>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_Names">
<title>Имена</title>

<para>
<firstterm>Имена</firstterm><indexterm><primary>имя</primary></indexterm>
состоят из букв от <literal>A</literal> до <literal>Z</literal> и
от <literal>a</literal> до <literal>z</literal>
(<constant>U+41</constant>—<constant>U+5A</constant>,
<constant>U+61</constant>—<constant>U+7A</constant>), десятичных цифр
(<constant>U+30</constant>—<constant>U+39</constant>), символов
<literal>_</literal> (<constant>U+5F</constant>), <literal>.</literal>
(<constant>U+2E</constant>), <literal>+</literal> (<constant>U+2B</constant>),
<literal>-</literal> (<constant>U+2D</constant>), <literal>=</literal>
(<constant>U+3D</constant>), <literal>$</literal> (<constant>U+24</constant>) и
не начинаются с десятичной цифры. Имени предшествует символ
<literal>/</literal> (<constant>U+2F</constant>).
</para>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_Commands">
<title>Команды</title>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_Arrays">
<title>Массивы</title>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_Procedures">
<title>Процедуры</title>

<para>
Символы <code language="psi">{</code> и <code language="psi">}</code>
используются для создания
<firstterm>процедур</firstterm><indexterm><primary>процедура</primary></indexterm>.
</para>

<para>
Интерпретация фрагмента программы

<programlisting language="psi">{ 1 exch div }</programlisting>

приводит к созданию объекта процедуры, которая содержит целочисленный объект
<code language="psi">1</code> и два объекта-команды <code
language="psi">exch</code> и <code language="psi">div</code>. Когда парсер
встречает символ <code language="psi">{</code>, он продолжает сканировать и
создавать объекты, однако интерпретатор их не исполняет. Когда парсер встречает
<code language="psi">}</code>, он помещает все объекты, созданные после
обнаружения <code language="psi">{</code> в новый объект-процедуру.
</para>

<para>
Интерпретатор не исполняет процедуру; вместо этого он загружает её на стек
операндов. Процедура будет исполнена лишь при её вызове. Исполнение процедуры
(и всех составляющих её объектов
<firstterm>отложенное</firstterm><indexterm><primary>исполнение</primary><secondary>отложенное</secondary></indexterm>).
Смысл отложенного исполнения объясняется в разделе <xref
linkend="PsiReference_Language_ObjectExecution"/>.
</para>

</section>

<section xml:id="PsiReference_Language_Syntax_Dictionaries">
<title>Словари</title>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_Sets">
<title>Множества</title>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Syntax_RegExps">
<title>Регулярные выражения</title>

<remark>TODO</remark>

</section>

</section>

<section xml:id="PsiReference_Language_CoreTypes">
<title>Основные типы</title>

<para>
Все данные в языке Ψ существуют в форме
<firstterm>объектов</firstterm><indexterm><primary>объект</primary></indexterm>.
Большинство объектов создаётся и обрабатывается операторами Ψ. Некоторые типы
объектов также создаются парсером и исполняются интерпретатором.
</para>

<para>
Каждый объект принадлежит некоторому
<firstterm>типу</firstterm><indexterm><primary>тип</primary></indexterm>. Тип
объекта влияет на то, как тот будет обрабатываться операторами. Типы
подразделяются
на <firstterm>простые</firstterm><indexterm><primary>тип</primary><secondary>простой</secondary></indexterm>
и
<firstterm>сложные</firstterm><indexterm><primary>тип</primary><secondary>сложный</secondary></indexterm>.
Разница между простыми и сложными объектами объясняется в разделе <xref
linkend="PsiReference_Language_CoreTypes_AtomicAndComposite"/>.  Ниже
приводится сводка простых и сложных типов, входящих в ядро языка.  Расширения
языка могут вводить новые типы объектов.
</para>

<informaltable frame="none" pgwide="1">
<tgroup cols="2" colsep="0">
<tbody valign="top">
<row>
<entry>
<itemizedlist>
<title>Простые типы</title>
<listitem><xref linkend="PsiReference_Types_Details_boolean" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_complex" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_integer" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_mark" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_name" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_command" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_null" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_operator" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_real" xrefstyle="template:%t"/></listitem>
</itemizedlist>
</entry>
<entry>
<itemizedlist>
<title>Сложные типы</title>
<listitem><xref linkend="PsiReference_Types_Details_array" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_bitset" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_bitvector" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_input" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_output" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_proc" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_random" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_reader" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_regexp" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_set" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_string" xrefstyle="template:%t"/></listitem>
<listitem><xref linkend="PsiReference_Types_Details_writer" xrefstyle="template:%t"/></listitem>
</itemizedlist>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<section xml:id="PsiReference_Language_CoreTypes_AtomicAndComposite">
<title>Простые и сложные объекты</title>

<para>
Объекты простых типов не могут быть изменены, они лишь создаются в результате
вычислений. Например, оператор <xref xrefstyle="template:%t"
linkend="PsiReference_Operators_Details_neg"/> не изменяет знак у самого числа,
а создаёт новый числовой объект, отличающийся знаком от исходного числа.
</para>

<para>
Объекты сложных типов могут изменять своё состояние. К примеру, оператор <xref
xrefstyle="template:%t" linkend="PsiReference_Operators_Details_put"/> заменяет
элемент массива, имеющий заданный индекс.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Operators">
<title>Операторы</title>

<para>
<firstterm>Оператор</firstterm><indexterm><primary>оператор</primary></indexterm>
в языке Ψ представляет код, манипулирующий интерпретатором. Объекты-операторы
имеют тип <xref linkend="PsiReference_Types_Details_operator"
xrefstyle="template:%t"/>.  Все операторы изначально размещены в системном
словаре и доступны по их именам. Операторы не могут быть созданы Ψ-программой.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Numbers">
<title>Числа</title>

<para>
В языке Ψ предусмотрены три числовых типа: целый (<xref
linkend="PsiReference_Types_Details_integer" xrefstyle="template:%t"/>),
вещественный (<xref linkend="PsiReference_Types_Details_real"
xrefstyle="template:%t"/>) и комплексный (<xref
linkend="PsiReference_Types_Details_complex" xrefstyle="template:%t"/>).
</para>

<para>
Объект целого типа представляет математическое целое число из диапазона от

<math xmlns="&nsMathML;">
	<mo>−</mo>
	<msup>
		<mn>2</mn>
		<mn>63</mn>
	</msup>
</math>

до

<math xmlns="&nsMathML;">
	<msup>
		<mn>2</mn>
		<mn>63</mn>
	</msup>
	<mo>−</mo>
	<mn>1</mn>
</math>

включительно.
</para>

<para>
Объект вещественного типа приближает математическое вещественное число
из существенно большего диапазона, однако с ограниченной точностью,
реализованное как число с плавающей точкой.
</para>

<para>
Объект комплексного типа представляет математическое комплексное число. Он
реализован как пара вещественных чисел — вещественная и мнимая части числа.
</para>

<para>
Большинство математических операторов Ψ могут применяться к операндам всех трёх
типов, производя при необходимости нужное преобразование типа.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Booleans">
<title>Булевские значения</title>

<para>
Объекты булевского типа (<xref linkend="PsiReference_Types_Details_boolean"
xrefstyle="template:%t"/>) представляют логические значения «ложь» и «правда».
Их главное предназначение — служить операндами в условных управляющих
операторах <xref linkend="PsiReference_Operators_Details_if"
xrefstyle="template:%t"/> и <xref
linkend="PsiReference_Operators_Details_ifelse" xrefstyle="template:%t"/>.  Оба
булевских объекта присутствуют в системном словаре под именами <xref
linkend="PsiReference_Operators_Details_false" xrefstyle="template:%t"/> и
<xref linkend="PsiReference_Operators_Details_true" xrefstyle="template:%t"/>.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Marks">
<title>Метки</title>

<para>
<firstterm>Метка</firstterm><indexterm><primary>метка</primary></indexterm> —
единственный объект типа <xref linkend="PsiReference_Types_Details_mark"
xrefstyle="template:%t"/> — служит для обозначения позиции на стеке операндов.
Метка доступна в системном словаре по именам <xref
linkend="PsiReference_Operators_Details_mark" xrefstyle="template:%t"/> (<xref
linkend="PsiReference_Operators_Details_[" xrefstyle="template:%t"/>, <xref
linkend="PsiReference_Operators_Details_&lt;" xrefstyle="template:%t"/>, <xref
linkend="PsiReference_Operators_Details_(" xrefstyle="template:%t"/>).
В основном метки служат операндами для операторов <xref
linkend="PsiReference_Operators_Details_arraytomark" xrefstyle="template:%t"/>
(<xref linkend="PsiReference_Operators_Details_]" xrefstyle="template:%t"/>),
<xref linkend="PsiReference_Operators_Details_dicttomark"
xrefstyle="template:%t"/> (<xref linkend="PsiReference_Operators_Details_&gt;"
xrefstyle="template:%t"/>), <xref
linkend="PsiReference_Operators_Details_settomark" xrefstyle="template:%t"/>
(<xref linkend="PsiReference_Operators_Details_)" xrefstyle="template:%t"/>),
<xref linkend="PsiReference_Operators_Details_counttomark"
xrefstyle="template:%t"/>, <xref
linkend="PsiReference_Operators_Details_cleartomark" xrefstyle="template:%t"/>.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Nulls">
<title>Пустой объект</title>

<para>
Особый тип <xref linkend="PsiReference_Types_Details_null"
xrefstyle="template:%t"/> содержит единственный объект. Этот объект служит
заполнителем в контейнерах, чьи элементы ещё не инициализированы. Главным
образом пустой объект появляется в массивах при увеличении их размера. Пустой
объект доступен в системном словаре по имени <xref
linkend="PsiReference_Operators_Details_null" xrefstyle="template:%t"/>. Он не
может быть операндом для большинства операторов.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Names">
<title>Имена</title>

<para>
<firstterm>Имена</firstterm><indexterm><primary>имя</primary></indexterm>
представляют неизменяемые строки. Имена главным образом используются как ключи
в словарях, по которым извлекаются соответствующие значения. С каждым
оператором языка Ψ ассоциировано имя в системном словаре.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Commands">
<title>Команды</title>

<para>
<firstterm>Команды</firstterm><indexterm><primary>команда</primary></indexterm>
(<firstterm>исполняемые
имена</firstterm><indexterm><primary>имя</primary><secondary>исполняемое</secondary></indexterm>)
отличаются от имён семантикой исполнения. Исполнение команды заключается
в поиске объекта, ассоциированого с именем команды, в стеке словарей, и
последующем исполнении найденного объекта.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Arrays">
<title>Массивы</title>

<para>
<firstterm>Массив</firstterm><indexterm><primary>массив</primary></indexterm> —
это контейнер для объектов, пронумерованных целыми неотрицательными числами
(<firstterm>индексами</firstterm><indexterm><primary>индекс</primary><secondary>массива</secondary></indexterm>).
Массивы в языке Ψ являются
<firstterm>неоднородными</firstterm><indexterm><primary>массив</primary><secondary>неоднородный</secondary></indexterm>,
то есть элементы массива могут быть объектами любого типа. В частности, массивы
могут содержать контейнеры (массивы, словари, множества), что позволяет
конструировать многомерные структуры данных любой сложности.
</para>

<para>
Массивы индексируются начиная с нуля. При доступе к элементам массива
осуществляется проверка границ индекса.  В случае выхода индекса за пределы
границ возбуждается ошибка <xref
linkend="PsiReference_Errors_Details_rangecheck" xrefstyle="template:%t"/>.
</para>

<para>
Длина массива может изменяться за счёт добавления или удаления элементов.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Procedures">
<title>Процедуры</title>

<para>
<firstterm>Процедура</firstterm><indexterm><primary>процедура</primary></indexterm>
(<firstterm>исполняемые
массивы</firstterm><indexterm><primary>массив</primary><secondary>исполняемый</secondary></indexterm>)
отличается от массива семантикой исполнения. Исполнение процедуры заключается
в поочерёдном исполнении всех её элементов.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Strings">
<title>Строки</title>

<para>
<firstterm>Строка</firstterm><indexterm><primary>строка</primary></indexterm>
концептуально устроена как массив, элементами которого служат целые числа
из диапазона от <math xmlns="&nsMathML;"><mn>0</mn></math> до <math
xmlns="&nsMathML;"><mn>65535</mn></math> — <firstterm>кодовые
единицы</firstterm><indexterm><primary>кодовая единица</primary></indexterm>.
</para>

<para>
Строки используются для хранения текста. Каждый символ текста представлен одной
или двумя кодовыми единицами в соответствии с кодировкой
<firstterm><acronym>UTF-16</acronym></firstterm><indexterm><primary>UTF-16</primary></indexterm>.
Одна кодовая единица кодирует символы из <firstterm>основной многоязычной
плоскости</firstterm><indexterm><primary>основная многоязычная
плоскость</primary><see><acronym>BMP</acronym></see></indexterm>
(<acronym>BMP</acronym><indexterm><primary><acronym>BMP</acronym></primary></indexterm>).
Остальные символы Unicode кодируются так называемыми <firstterm>суррогатными
парами</firstterm><indexterm><primary>суррогатная пара</primary></indexterm>.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_Dictionaries">
<title>Словари</title>

<para>
<firstterm>Словарь</firstterm><indexterm><primary>словарь</primary></indexterm> представляет
собой контейнер для объектов, проиндексированных именами. Такие структуры
называют также <firstterm>ассоциативными
массивами</firstterm><indexterm><primary>массив</primary><secondary>ассоциативный</secondary></indexterm>.
</para>

<para>
Словари интенсивно используются интерпретатором для ассоциации объектов
(по большей части операторов и процедур) с именами. Каждый раз, когда парсер
обнаруживает команду, интерпретатор осуществляет поиск объекта по имени команды
в стеке словарей, после чего исполняет найденный объект.
</para>

</section>

<section xml:id="PsiReference_Language_CoreTypes_RegExps">
<title>Регулярные выражения</title>

<para>
<firstterm>Регулярное выражение</firstterm><indexterm><primary>регулярное
выражение</primary></indexterm> представляет шаблон поиска в строке.
</para>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs">
<title>Конструкции в регулярных выражениях</title>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs_Characters">
<title>Символы</title>

<informaltable pgwide="1">
<tgroup cols="2">
<colspec colwidth="1*"/>
<colspec colwidth="3*"/>
<tbody>
<row>
<entry><literal><replaceable>X</replaceable></literal></entry>
<entry>символ <replaceable>X</replaceable></entry>
</row>
<row>
<entry><literal>\\</literal></entry>
<entry>символ бэкслэш (<constant>U+5C</constant>)</entry>
</row>
<row>
<entry><literal>\u<replaceable>HHHH</replaceable></literal></entry>
<entry>символ с шестнадцатеричным значением <replaceable>HHHH</replaceable></entry>
</row>
<row>
<entry><literal>\x<replaceable>H…H</replaceable></literal></entry>
<entry>символ с шестнадцатеричным значением <replaceable>H…H</replaceable></entry>
</row>
<row>
<entry><literal>\t</literal></entry>
<entry>символ табуляции (<constant>U+9</constant>)</entry>
</row>
<row>
<entry><literal>\n</literal></entry>
<entry>символ конца строки (<constant>U+A</constant>)</entry>
</row>
<row>
<entry><literal>\r</literal></entry>
<entry>символ возврата каретки (<constant>U+D</constant>)</entry>
</row>
<row>
<entry><literal>\f</literal></entry>
<entry>символ конца страницы (<constant>U+C</constant>)</entry>
</row>
<row>
<entry><literal>\a</literal></entry>
<entry>символ гудка (<constant>U+7</constant>)</entry>
</row>
<row>
<entry><literal>\e</literal></entry>
<entry>символ escape (<constant>U+1B</constant>)</entry>
</row>
<row>
<entry><literal>\c<replaceable>X</replaceable></literal></entry>
<entry>управляющий символ, соответствующий <replaceable>X</replaceable></entry>
</row>
</tbody>
</tgroup>
</informaltable>

</section>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs_CharacterClasses">
<title>Символьные классы</title>

<informaltable pgwide="1">
<tgroup cols="2">
<colspec colwidth="1*"/>
<colspec colwidth="3*"/>
<tbody>
<row>
<entry><literal>[abc]</literal></entry>
<entry><literal>a</literal>, <literal>b</literal> или <literal>c</literal></entry>
</row>
<row>
<entry><literal>[^abc]</literal></entry>
<entry>любой символ, кроме <literal>a</literal>, <literal>b</literal> и <literal>c</literal></entry>
</row>
<row>
<entry><literal>[A-Za-z]</literal></entry>
<entry>символы от <literal>A</literal> до <literal>Z</literal> или
от <literal>a</literal> до <literal>z</literal> (включительно)</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</section>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs_PredefinedCharacterClasses">
<title>Предопределённые символьные классы</title>

<informaltable pgwide="1">
<tgroup cols="2">
<colspec colwidth="1*"/>
<colspec colwidth="3*"/>
<tbody>
<row>
<entry><literal>.</literal></entry>
<entry>любой символ</entry>
</row>
<row>
<entry><literal>\d</literal></entry>
<entry>десятичная цифра, <literal>[0-9]</literal></entry>
</row>
<row>
<entry><literal>\D</literal></entry>
<entry>не десятичная цифра, <literal>[^0-9]</literal></entry>
</row>
<row>
<entry><literal>\s</literal></entry>
<entry>пробельный символ, <literal>[ \t\n\r\f\x{0B}]</literal></entry>
</row>
<row>
<entry><literal>\S</literal></entry>
<entry>непробельный символ, <literal>[^ \t\n\r\f\x{0B}]</literal></entry>
</row>
<row>
<entry><literal>\w</literal></entry>
<entry>словный символ, <literal>[A-Za-z_\d]</literal></entry>
</row>
<row>
<entry><literal>\W</literal></entry>
<entry>не словный символ, <literal>[^A-Za-z_\d]</literal></entry>
</row>
</tbody>
</tgroup>
</informaltable>

</section>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs_POSIXCharacterClasses">
<title>Символьные классы POSIX</title>

</section>

<section xml:id="PsiReference_Language_CoreTypes_RegExps_Constructs_Boundaries">
<title>Граничные привязки</title>

<informaltable pgwide="1">
<tgroup cols="2">
<colspec colwidth="1*"/>
<colspec colwidth="3*"/>
<tbody>
<row>
<entry><literal>^</literal></entry>
<entry>начало строки</entry>
</row>
<row>
<entry><literal>$</literal></entry>
<entry>конец строки</entry>
</row>
<row>
<entry><literal>\b</literal></entry>
<entry>граница слова</entry>
</row>
<row>
<entry><literal>\B</literal></entry>
<entry>не граница слова</entry>
</row>
<row>
<entry><literal>\A</literal></entry>
<entry>начало входа</entry>
</row>
<row>
<entry><literal>\G</literal></entry>
<entry>конец последнего совпадения</entry>
</row>
<row>
<entry><literal>\Z</literal></entry>
<entry>TODO</entry>
</row>
<row>
<entry><literal>\z</literal></entry>
<entry>TODO</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</section>

</section>

</section>

</section>

<section xml:id="PsiReference_Language_Stacks">
<title>Стеки</title>

<para>
Интерпретатор Ψ поддерживает несколько стеков, предназначенных для хранения
данных во время исполнения программы или для представления состояния её
исполнения. Три из них являются ключевыми — <firstterm>стек
операндов</firstterm><indexterm><primary>стек</primary><secondary>операндов</secondary></indexterm>,
<firstterm>стек
словарей</firstterm><indexterm><primary>стек</primary><secondary>словарей</secondary></indexterm>
и <firstterm>стек
исполнения</firstterm><indexterm><primary>стек</primary><secondary>исполнения</secondary></indexterm>.
</para>

<para>
Каждый из стеков устроен по принципу <acronym>LIFO</acronym> — <foreignphrase
xml:lang="en">Last In—First Out</foreignphrase> (последний пришёл — первый ушёл).
</para>

<section xml:id="PsiReference_Language_Stacks_OperandStack">
<title>Стек операндов</title>

<para>
Исполнение литеральных объектов всегда приводит к их добавлению в стек
операндов. Если оператор нуждается в данных для обработки, он снимает нужное
количество объектов их со стека операндов. Объекты, созданные в результате
работы оператора, добавлются в этот стек. Так действует большинство операторов
языка. Таким образом, свободно манипулировать стеком операндов может как
интерпретатор, так и любой из операторов.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_DictionaryStack">
<title>Стек словарей</title>

<para>
Стек словарей способен хранить только словари. Текущее состояние стека словарей
служит контекстом для поиска объектов по именам. Необходимость в таком поиске
возникает каждый раз, когда интерпретатор встречает команду. Имеется
несколько операторов, предназначенных для управления стеком словарей.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_ExecutionStack">
<title>Стек исполнения</title>

<para>
Стек исполнения отражает фазу исполнения процедуры. При исполнении процедуры её
элементы загружаются на стек исполнения в обратном порядке, так что самый
первый элемент оказывается на вершине стека. Затем интерпретатор по очереди
снимает объекты из стека исполнения и исполняет их до тех пор, пока уровень
стека не сравняется с первоначальным (тем, что был к началу исполнения
процедуры).
</para>

<para>
Стек исполнения служит также для поддержки исполнения исполняемых строк и
читателей: эти объекты преобразуются в процедуры, которые, в свою очередь,
исполняются в соответствии с описанными выше правилами.
</para>

<para>
Стеком исполнения может управлять интерпретатор. В языке лишь несколько
операторов, управляющих напрямую стеком исполнения. Это управляющие операторы,
реализующие циклы.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_Auxiliary">
<title>Служебные стеки</title>

<para>
Помимо трёх основных стеков, в интерпретатор встроены и другие, служебные. Это
<firstterm>стек контекстов
выхода</firstterm><indexterm><primary>стек</primary><secondary>контекстов
выхода</secondary></indexterm> и <firstterm>стек контекстов
остановки</firstterm><indexterm><primary>стек</primary><secondary>контекстов
остановки</secondary></indexterm>. Используют служебные стеки лишь несколько
управляющих операторов.
</para>

</section>

</section>

<section xml:id="PsiReference_Language_ObjectExecution">
<title>Исполнение объектов</title>

<para>
Смысл исполнения объекта зависит от его типа, а также от того, получен этот
объект парсером или же другим способом. Здесь нужно отметить, что существует
лишь два типа исполненяемых объектов, получаемых непосредственно парсером — это
процедуры и команды.

<itemizedlist>

<listitem>
Исполняемый оператор вызывается, то есть выполняется запрограммированное в нём
действие.
</listitem>

<listitem>
Объекты всех прочих типов загружаются на стек операндов.
</listitem>

</itemizedlist>

</para>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding">
<title>Раннее связывание имён</title>

<section xml:id="PsiReference_Language_EarlyNameBinding_BindOperator">
<title>Оператор <xref xrefstyle="template:%t" linkend="PsiReference_Operators_Details_bind"/></title>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding_Immediate">
<title>Немедленные имена</title>

</section>

</section>

<section xml:id="PsiReference_Language_MultipleExecutionContexts">
<title>Множественные контексты исполнения</title>

<para>
В языке Ψ имеется поддержка асинхронных <firstterm>контекстов
исполнения</firstterm><indexterm><primary>контекст</primary>
<secondary>исполнения</secondary></indexterm>. Контекст исполнения представляет
собой отдельный интерпретатор.
</para>

<remark>TODO</remark>

</section>

<section xml:id="PsiReference_Language_Errors">
<title>Ошибки</title>

<para>
Во время исполнения программы Ψ возможны различные ошибки. Некоторые из них
генерируются интерпретатором. Другие возникают при исполнении операторов,
например, ошибки несоответствия типа операндов или недополнения стека
операндов.
</para>

<para>
Ошибки отнесены к нескольким типам. Каждому типу соответствует имя, например,
<xref xrefstyle="template:%t" linkend="PsiReference_Errors_Details_typecheck"/>
или <xref xrefstyle="template:%t"
linkend="PsiReference_Errors_Details_stackunderflow"/>. Подробное описание
разных типов ошибок имеется в главе <xref linkend="PsiReference_Errors"/>.
</para>

<para>
Обработка всех ошибок проводится единообразно.
</para>

</section>

<section xml:id="PsiReference_Language_Grammar">
<title>Грамматика</title>

<productionset>
<title>Грамматические правила для токенов</title>

<production xml:id="PsiReference_Language_Grammar_Token">
<lhs>TOKEN</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerHexadecimal">INTEGER_HEXADECIMAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerBinary">INTEGER_BINARY</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Char">CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Real">REAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_String">STRING</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExp">REGEXP</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Immediate">IMMEDIATE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_OpenBrace">OPEN_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CloseBrace">CLOSE_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Comment">COMMENT</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Sign">
<lhs>SIGN</lhs>
<rhs>[<constant>"+"</constant>, <constant>"-"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Digit">
<lhs>DIGIT</lhs>
<rhs>[<constant>"0"</constant> - <constant>"9"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerUnsigned">
<lhs>INTEGER_UNSIGNED</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Integer">
<lhs>INTEGER</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_HexDigit">
<lhs>HEXDIGIT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>
| [<constant>"A"</constant> - <constant>"F"</constant>,
<constant>"a"</constant> - <constant>"f"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerHexadecimal">
<lhs>INTEGER_HEXADECIMAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"X"</constant>,
<constant>"x"</constant>]
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerBinary">
<lhs>INTEGER_BINARY</lhs>
<rhs>
<nonterminal def="PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"B"</constant>, <constant>"b"</constant>]
[<constant>"0"</constant>, <constant>"1"</constant>]+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Char">
<lhs>CHAR</lhs>
<rhs>
<constant>"`"</constant>
(~[<constant>"\\"</constant>]
| <nonterminal def="PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>)
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RealUnsigned">
<lhs>REAL_UNSIGNED</lhs>
<rhs>
(<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
(<constant>"."</constant>
<nonterminal>DIGIT</nonterminal>*)?
| <constant>"."</constant>
<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>)
<nonterminal def="PsiReference_Language_Grammar_Exponent">EXPONENT</nonterminal>?
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Real">
<lhs>REAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_RealUnsigned">REAL_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Exponent">
<lhs>EXPONENT</lhs>
<rhs>
[<constant>"E"</constant>, <constant>"e"</constant>]
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Comment">
<lhs>COMMENT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_CommentOneLine">COMMENT_ONELINE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CommentMultiline">COMMENT_MULTILINE</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentOneLine">
<lhs>COMMENT_ONELINE</lhs>
<rhs>
<constant>"#"</constant>
(~[<constant>"\n"</constant>])*
<constant>"\n"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentMultiline">
<lhs>COMMENT_MULTILINE</lhs>
<rhs>
<constant>"/#"</constant>
(~[<constant>"/"</constant>]
| (<constant>"/"</constant> ~[<constant>"#"</constant>]))*
<constant>"#/"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_String">
<lhs>STRING</lhs>
<rhs>
<constant>"\""</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| ~[ <constant>"\""</constant>,
<constant>"\\"</constant>])*
<constant>"\""</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_StringSpecial">
<lhs>STRING_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
([<constant>"0"</constant>,
<constant>"a"</constant>,
<constant>"n"</constant>,
<constant>"t"</constant>,
<constant>"f"</constant>,
<constant>"\""</constant>,
<constant>"\\"</constant>,
<constant>"e"</constant>,
<constant>"r"</constant>,
<constant>"\n"</constant>]
<sbr/>
| <constant>"u"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>{4}
| <constant>"x{"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+
<constant>"}"</constant>
| <constant>"c"</constant>
[<constant>"\u0000" - "\u00FF"</constant>])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExp">
<lhs>REGEXP</lhs>
<rhs>
<constant>"@"</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExpSpecial">REGEXP_SPECIAL</nonterminal>
| ~[<constant>"@"</constant>,
<constant>"\\"</constant>])*
<constant>"@"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExpSpecial">
<lhs>REGEXP_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
(~[])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Name">
<lhs>NAME</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Immediate">
<lhs>IMMEDIATE</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Command">
<lhs>COMMAND</lhs>
<rhs>
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>)
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>)*<sbr/>
| [<constant>"["</constant>,
<constant>"]"</constant>,
<constant>"("</constant>,
<constant>")"</constant>,
<constant>"&lt;"</constant>,
<constant>"&gt;"</constant>,
<constant>"="</constant>,
<constant>"?"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_OpenBrace">
<lhs>OPEN_BRACE</lhs>
<rhs><constant>"{"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CloseBrace">
<lhs>CLOSE_BRACE</lhs>
<rhs><constant>"}"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Letter">
<lhs>LETTER</lhs>
<rhs>
[<constant>"A"</constant> - <constant>"Z"</constant>,
<constant>"a"</constant> - <constant>"z"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_NameSpecialChar">
<lhs>NAME_SPECIAL_CHAR</lhs>
<rhs>
[<constant>"_"</constant>,
<constant>"."</constant>,
<constant>"+"</constant>,
<constant>"-"</constant>,
<constant>"="</constant>,
<constant>"$"</constant>]
</rhs>
</production>

</productionset>

</section>

</chapter>
