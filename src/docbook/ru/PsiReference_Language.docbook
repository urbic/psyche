<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="PsiReference_Language">
<title>Язык</title>

&PsiReference_Language_Interpreter;
&PsiReference_Language_Syntax;
&PsiReference_Language_CoreTypes;

<section xml:id="PsiReference_Language_Stacks">
<title>Стеки</title>

<para>
Интерпретатор Ψ поддерживает несколько стеков, предназначенных для хранения
данных во время исполнения программы или для представления состояния её
исполнения. Три из них являются ключевыми — <firstterm>стек
операндов</firstterm><indexterm><primary>стек</primary><secondary>операндов</secondary></indexterm>,
<firstterm>стек
словарей</firstterm><indexterm><primary>стек</primary><secondary>словарей</secondary></indexterm>
и <firstterm>стек
исполнения</firstterm><indexterm><primary>стек</primary><secondary>исполнения</secondary></indexterm>.
</para>

<para>
Каждый из стеков устроен по принципу <acronym>LIFO</acronym> — <foreignphrase
xml:lang="en">Last In—First Out</foreignphrase> (последний пришёл — первый ушёл).
</para>

<section xml:id="PsiReference_Language_Stacks_OperandStack">
<title>Стек операндов</title>

<para>
Исполнение литеральных объектов всегда приводит к их добавлению в стек
операндов. Если оператор нуждается в данных для обработки, он снимает нужное
количество объектов их со стека операндов. Объекты, созданные в результате
работы оператора, добавлются в этот стек. Так действует большинство операторов
языка. Таким образом, свободно манипулировать стеком операндов может как
интерпретатор, так и любой из операторов.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_DictionaryStack">
<title>Стек словарей</title>

<para>
Стек словарей способен хранить только словари. Текущее состояние стека словарей
служит контекстом для поиска объектов по именам. Необходимость в таком поиске
возникает каждый раз, когда интерпретатор встречает команду. Имеется
несколько операторов, предназначенных для управления стеком словарей.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_ExecutionStack">
<title>Стек исполнения</title>

<para>
Стек исполнения отражает фазу исполнения процедуры. При исполнении процедуры её
элементы загружаются на стек исполнения в обратном порядке, так что самый
первый элемент оказывается на вершине стека. Затем интерпретатор по очереди
снимает объекты из стека исполнения и исполняет их до тех пор, пока уровень
стека не сравняется с первоначальным (тем, что был к началу исполнения
процедуры).
</para>

<para>
Стеком исполнения может управлять интерпретатор. В языке есть лишь несколько
операторов, управляющих напрямую стеком исполнения. Это управляющие операторы,
реализующие циклы.
</para>

</section>

<section xml:id="PsiReference_Language_Stacks_Auxiliary">
<title>Служебные стеки</title>

<para>
Помимо трёх основных стеков, в интерпретатор встроены и другие, служебные. Это
<firstterm>стек контекстов
выхода</firstterm><indexterm><primary>стек</primary><secondary>контекстов
выхода</secondary></indexterm> и <firstterm>стек контекстов
остановки</firstterm><indexterm><primary>стек</primary><secondary>контекстов
остановки</secondary></indexterm>. Используют служебные стеки лишь несколько
управляющих операторов.
</para>

</section>

</section>

<section xml:id="PsiReference_Language_ObjectExecution">
<title>Исполнение объектов</title>

<para>
Смысл исполнения объекта зависит от его типа, а также от того, получен этот
объект парсером или же другим способом. Здесь нужно отметить, что существует
лишь два типа исполненяемых объектов, получаемых непосредственно парсером — это
процедуры и команды.

<itemizedlist>

<listitem>
Исполняемый оператор вызывается, то есть выполняется запрограммированное в нём
действие.
</listitem>

<listitem>
Объекты всех прочих типов загружаются на стек операндов.
</listitem>

</itemizedlist>

</para>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding">
<title>Раннее связывание имён</title>

<section xml:id="PsiReference_Language_EarlyNameBinding_BindOperator">
<title>Оператор <xref xrefstyle="template:%t" linkend="PsiReference_Operators_Details_bind"/></title>

</section>

<section xml:id="PsiReference_Language_EarlyNameBinding_Immediate">
<title>Немедленные имена</title>

</section>

</section>

&PsiReference_Language_IO;
&PsiReference_Language_MultipleContextExecution;
&PsiReference_Language_Errors;

<section xml:id="PsiReference_Language_Grammar">
<title>Грамматика</title>

<productionset>
<title>Грамматические правила для токенов</title>

<production xml:id="PsiReference_Language_Grammar_Token">
<lhs>TOKEN</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerHexadecimal">INTEGER_HEXADECIMAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_IntegerBinary">INTEGER_BINARY</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Char">CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Real">REAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_String">STRING</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExp">REGEXP</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Immediate">IMMEDIATE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_OpenBrace">OPEN_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CloseBrace">CLOSE_BRACE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Comment">COMMENT</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Sign">
<lhs>SIGN</lhs>
<rhs>[<constant>"+"</constant>, <constant>"-"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Digit">
<lhs>DIGIT</lhs>
<rhs>[<constant>"0"</constant> - <constant>"9"</constant>]</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerUnsigned">
<lhs>INTEGER_UNSIGNED</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Integer">
<lhs>INTEGER</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_HexDigit">
<lhs>HEXDIGIT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>
| [<constant>"A"</constant> - <constant>"F"</constant>,
<constant>"a"</constant> - <constant>"f"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerHexadecimal">
<lhs>INTEGER_HEXADECIMAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"X"</constant>,
<constant>"x"</constant>]
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_IntegerBinary">
<lhs>INTEGER_BINARY</lhs>
<rhs>
<nonterminal def="PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<constant>"0"</constant>
[<constant>"B"</constant>, <constant>"b"</constant>]
[<constant>"0"</constant>, <constant>"1"</constant>]+
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Char">
<lhs>CHAR</lhs>
<rhs>
<constant>"`"</constant>
(~[<constant>"\\"</constant>]
| <nonterminal def="PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>)
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RealUnsigned">
<lhs>REAL_UNSIGNED</lhs>
<rhs>
(<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>
(<constant>"."</constant>
<nonterminal>DIGIT</nonterminal>*)?
| <constant>"."</constant>
<nonterminal def="PsiReference_Language_Grammar_IntegerUnsigned">INTEGER_UNSIGNED</nonterminal>)
<nonterminal def="PsiReference_Language_Grammar_Exponent">EXPONENT</nonterminal>?
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Real">
<lhs>REAL</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_Sign">SIGN</nonterminal>?
<nonterminal def="#PsiReference_Language_Grammar_RealUnsigned">REAL_UNSIGNED</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Exponent">
<lhs>EXPONENT</lhs>
<rhs>
[<constant>"E"</constant>, <constant>"e"</constant>]
<nonterminal def="#PsiReference_Language_Grammar_Integer">INTEGER</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Comment">
<lhs>COMMENT</lhs>
<rhs>
<nonterminal def="#PsiReference_Language_Grammar_CommentOneLine">COMMENT_ONELINE</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_CommentMultiline">COMMENT_MULTILINE</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentOneLine">
<lhs>COMMENT_ONELINE</lhs>
<rhs>
<constant>"#"</constant>
(~[<constant>"\n"</constant>])*
<constant>"\n"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CommentMultiline">
<lhs>COMMENT_MULTILINE</lhs>
<rhs>
<constant>"/#"</constant>
(~[<constant>"/"</constant>]
| (<constant>"/"</constant> ~[<constant>"#"</constant>]))*
<constant>"#/"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_String">
<lhs>STRING</lhs>
<rhs>
<constant>"\""</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| ~[ <constant>"\""</constant>,
<constant>"\\"</constant>])*
<constant>"\""</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_StringSpecial">
<lhs>STRING_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
([<constant>"0"</constant>,
<constant>"a"</constant>,
<constant>"n"</constant>,
<constant>"t"</constant>,
<constant>"f"</constant>,
<constant>"\""</constant>,
<constant>"\\"</constant>,
<constant>"e"</constant>,
<constant>"r"</constant>,
<constant>"\n"</constant>]
<sbr/>
| <constant>"u"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>{4}
| <constant>"x{"</constant>
<nonterminal def="PsiReference_Language_Grammar_HexDigit">HEXDIGIT</nonterminal>+
<constant>"}"</constant>
| <constant>"c"</constant>
[<constant>"\u0000" - "\u00FF"</constant>])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExp">
<lhs>REGEXP</lhs>
<rhs>
<constant>"@"</constant>
(<nonterminal def="#PsiReference_Language_Grammar_StringSpecial">STRING_SPECIAL</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_RegExpSpecial">REGEXP_SPECIAL</nonterminal>
| ~[<constant>"@"</constant>,
<constant>"\\"</constant>])*
<constant>"@"</constant>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_RegExpSpecial">
<lhs>REGEXP_SPECIAL</lhs>
<rhs>
<constant>"\\"</constant>
(~[])
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Name">
<lhs>NAME</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Command">COMMAND</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Immediate">
<lhs>IMMEDIATE</lhs>
<rhs>
<constant>"/"</constant>
<nonterminal def="#PsiReference_Language_Grammar_Name">NAME</nonterminal>
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Command">
<lhs>COMMAND</lhs>
<rhs>
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>)
(<nonterminal def="#PsiReference_Language_Grammar_Letter">LETTER</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_NameSpecialChar">NAME_SPECIAL_CHAR</nonterminal>
| <nonterminal def="#PsiReference_Language_Grammar_Digit">DIGIT</nonterminal>)*<sbr/>
| [<constant>"["</constant>,
<constant>"]"</constant>,
<constant>"("</constant>,
<constant>")"</constant>,
<constant>"&lt;"</constant>,
<constant>"&gt;"</constant>,
<constant>"="</constant>,
<constant>"?"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_OpenBrace">
<lhs>OPEN_BRACE</lhs>
<rhs><constant>"{"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_CloseBrace">
<lhs>CLOSE_BRACE</lhs>
<rhs><constant>"}"</constant></rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_Letter">
<lhs>LETTER</lhs>
<rhs>
[<constant>"A"</constant> - <constant>"Z"</constant>,
<constant>"a"</constant> - <constant>"z"</constant>]
</rhs>
</production>

<production xml:id="PsiReference_Language_Grammar_NameSpecialChar">
<lhs>NAME_SPECIAL_CHAR</lhs>
<rhs>
[<constant>"_"</constant>,
<constant>"."</constant>,
<constant>"+"</constant>,
<constant>"-"</constant>,
<constant>"="</constant>,
<constant>"$"</constant>]
</rhs>
</production>

</productionset>

</section>

</chapter>
